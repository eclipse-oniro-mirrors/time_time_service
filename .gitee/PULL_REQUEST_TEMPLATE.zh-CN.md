### 相关的Issue


### 原因（目的、解决的问题等）


### 描述（做了什么，变更了什么）


### 验证结果（新增、改动、可能影响的功能）


### 稳定性排查：
- [ ] 【规则】禁止在锁内向其他进程发送IPC（进程间通信）;
- [ ] 【规则】禁止将捕获**栈变量引用**的lambda函数**异步到其他线程执行**;
- [ ] 【规则】禁止传递this指针至其他模块或线程(特别是eventhandler任务);
- [ ] 【规则】禁止存储string的c_str()方法获取到的指针;
- [ ] 【规则】成员变量进行赋值或创建需要排查并发;
- [ ] 【规则】谨慎在未经拷贝的情况下使用外部传入的string、C字符串;
- [ ] 【规则】map\vector\list\set等stl模板类使用时需要排查并发;
- [ ] 【规则】谨慎考虑加锁范围，尽可能的小范围加锁;
- [ ] 【规则】在IPC通信中谨慎使用同步通信方式;
- [ ] 【规则】禁止将外部传入的裸指针在内部直接构造智能指针;
- [ ] 【规则】禁止多个独立创建的智能指针管理同一地址;
- [ ] 【规则】禁止在析构函数中抛异步任务;
- [ ] 【规则】禁止js对象在非js线程(例如在IPC线程)创建、使用或销毁;
- [ ] 【规则】禁止在对外接口中未经判空直接使用外部传入的指针;
- [ ] 【规则】监听回调要确保，回调触发和取消注册并发时无生命周期问题;
- [ ] 【规则】遍历容器进行删除或插入时注意迭代器失效问题;

### 日志规范自检：
- [ ] 【规则】日志精简表明扼要，结尾不加句号

### 安全编码自检：
- [ ] 【内存管理】内存申请前必须对内存大小进行合法性校验;
- [ ] 【内存管理】内存申请后必须判空，判断内存申请是否成功;
- [ ] 【内存管理】分配和释放内存(or fd等资源)的函数需要成对出现;
- [ ] 【内存管理】申请内存后异常退出前需要及时进行内存释放;
- [ ] 【内存管理】正则表达式构造后需释放资源，regcomp/regexec与regfree必须成对使用;
- [ ] 【内存管理】realpath使用时如果resolved_path为NULL需要注意内存释放;
- [ ] 【外部输入校验】解析数据后拷贝时需校验源buffer实际缓冲区大小，避免越界读写;
- [ ] 【外部输入校验】使用外部输入作为循环变量时，需要校验循环变量上限是否合理，防止出现超大循环;
- [ ] 【外部输入校验】禁止直接使用外部输入作为数组下标，防止出现内存越界;
- [ ] 【敏感信息】堆、栈中保存密钥、口令（包括加密后的变量）变量使用完后必须显式覆盖或清空;
- [ ] 【加密算法】禁止使用私有加密算法或不安全加密算法;
- [ ] 【变量初始化】指针变量、表示资源描述符的变量、bool变量必须赋初值;
- [ ] 【指针】IPC流程中ReadCString、ReadRawData、readParcelable等结果必须判空;
- [ ] 【整数运算】整数之间运算时必须严格检查，确保不会出现溢出、反转、除0;
- [ ] 【整数运算】禁止对有符号整数进行位操作符运算;
- [ ] 【循环变量】循环次数如果受外部数据控制，需要检验其合法性;
- [ ] 【循环变量】循环变量和中止条件的数据类型定义保持一致;
- [ ] 【安全函数】安全函数必须检查返回值，并进行正确处理;
- [ ] 【安全函数】安全函数目标缓冲区入参大小与目标缓冲区实际大小必须一致;
- [ ] 【常见问题】修改单个函数时，如果涉及新增异常返回分支，必须排查是否需要释放锁、内存、fd等资源;
- [ ] 【常见问题】函数返回值需与函数签名相同，参数定义需在同一范畴(不能定义bool，返回int32_t)，或同一枚举类型;
- [ ] 【常见问题】格式化打印类型需匹配，例如：int32_t %d; uint32_t %u; long %ld; unsigned long %lu; long long PRId64;<br> unsigned long long PRIu64;
- [ ] 【常见问题】对任何数据结构操作时，需要考虑插入时是否有可能造成重复，如果可能重复，删除时需要删除全部的数据；
- [ ] 【常见问题】修改函数时，需要查看所有调用该函数的地方；

### 测试规范自检：
- [ ] 【规则】测试归属目录需根据测试类型及功能所属正确区分；
- [ ] 【规则】测试名需体现测试功能或函数，测试描述需表明测试目的；
- [ ] 【规则】测试断言需明确具体错误类型，而不能仅判断非ERROR_OK；
